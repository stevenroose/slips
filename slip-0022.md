# SLIP-0022 : FIDO2 credential ID format for HD wallets

```
Number:  SLIP-0022
Title:   FIDO2 credential ID format for HD wallets
Type:    Standard
Status:  Draft
Authors: Andrew R. Kozlik <andrew.kozlik@satoshilabs.com>
         Pavol Rusnak <stick@satoshilabs.com>
         Ondrej Vejpustek <ondrej.vejpustek@satoshilabs.com>
Created: 2019-07-19
```

## Abstract

This document describes an interoperable format for FIDO2 credential IDs for use in hierarchical deterministic wallets.

## Motivation

A FIDO2 credential ID is a probabilistically-unique byte sequence identifying a public key credential. It is generated by the authenticator during registration and stored by the relying party and optionally by the authenticator. One way to generate a credential ID is to encrypt all credential data so that only its managing authenticator can decrypt it. This form allows the authenticator to be nearly stateless, by having the relying party store any necessary state. This specification defines a format for credential IDs which is suited for use in hierarchical deterministic wallets.

This format may also be used for U2F key handles. However the usage for FIDO2 and U2F has to be domain-separated, which is ensured by using different keys.

## Credential ID format

The credential ID is a byte string between 30 and 65535 bytes in length of the following form:

Version | Initialization vector | Encrypted credential data | Authentication tag
--------|-----------------------|---------------------------|-------------------
1 byte  | 12 bytes              | variable length           | 16 bytes

The version is a byte with value `0x01`. The initialization vector is a randomly generated 96-bit value followed by Chacha20Poly1305 encrypted credential data and a 16 byte authentication tag.

## Credential data encoding

The credential data is encoded as a CBOR map with integer keys. This method is used to encode CTAP2 command parameters and response members. It allows easy handling of optional members, deprecating old members and introducing new members.

Member name     | Key | Value type                            | Required                 | Definition
----------------|-----|---------------------------------------|--------------------------|-------------------------
rpId            | 1   | Text string (CBOR major type 3).      | Required for FIDO2.      | Relying party identifier. The "id" member of the rp parameter from the authenticatorMakeCredential request.
rpName          | 2   | Text string (CBOR major type 3).      | Optional.                | Relying party name. The "name" member of the rp parameter from the authenticatorMakeCredential request.
userId          | 3   | Byte string (CBOR major type 2).      | Required for FIDO2.      | User account ID. The "id" member of the user parameter from the authenticatorMakeCredential request.
userName        | 4   | Text string (CBOR major type 3).      | Optional.                | User account name. The "name" member of the user parameter from the authenticatorMakeCredential request.
userDisplayName | 5   | Text string (CBOR major type 3).      | Optional.                | User account display name. The "displayName" member of the user parameter from the authenticatorMakeCredential request.
creationTime    | 6   | Unsigned integer (CBOR major type 0). | Required for FIDO2.      | Any value which allows credentials to be sorted by the time of their creation, such as the UNIX timestamp or the value of an incremental counter at the moment of creation.
hmacSecret      | 7   | Boolean (CBOR simple value 21).       | Optional, default false. | Indicates whether the credential was created with the hmac-secret extension set to true.

## Encryption

The CBOR encoded data is encrypted using Chacha20Poly1305 as defined in [RFC 8439](https://tools.ietf.org/html/rfc8439). In case of FIDO2 the rpId is used as the AAD input to the cipher. In case of U2F the application parameter (SHA-256 hash of the UTF-8 encoding of the application identity) is used as the AAD input to the cipher.

The encryption key *k* is the same for all credentials. It is derived from a master secret using [SLIP-0021](https://github.com/satoshilabs/slips/blob/master/slip-0021.md) as:

```
k = Key(m/"SLIP-0022"/"FIDO2")
```

in case of FIDO2 credentials, or as

```
k = Key(m/"SLIP-0022"/"U2F")
```

in case of U2F key handles.

## Derivation of credential key pair

The NIST P-256 credential key pair is derived from a master secret and the authentication tag of the credential ID using [SLIP-0010](https://github.com/satoshilabs/slips/blob/master/slip-0010.md). The key path is computed from the authentication tag by splitting it into four 4-byte values A, B, C and D which are interpreted as 32-bit integers in little-endian byte order. The highest bit in each integer is set and the key path is:

```
m/0x10022'/0x02'/A'/B'/C'/D'
```

in case of FIDO2 credentials, or as

```
m/0x10022'/0x01'/A'/B'/C'/D'
```

in case of U2F key handles.

## Derivation hmac-secret CredRandom

The CredRandom value is derived from the master secret and the credential ID using SLIP-0021:

```
CredRandom = Key(m/"SLIP-0022"/"FIDO2"/CredentialID)
```

## Design rationale

### Initialization vector

The 12 byte initialization vector ensures that even if a user were to generate 2<sup>32</sup> credentials, then the likelihood of a collision occurring would be below 2<sup>&minus;32</sup>.

### Key derivation

* The key path is not a confidential piece of information so it does not need to be encrypted or derived with the knowledge of a secret key.
* The key path should depend on the credential information and on the relying party identifier, which is provided as AAD when computing the authentication tag.
* There should be an element of randomness so that different keys are generated even if the credential information is the same. Consider for example a relying party which insists on rotating the authentication key every three months and keeps track of old keys. The randomness is ensured by the fact that the IV is generated randomly.
* Key path collisions should be near impossible. The likelihood of a collision occurring is even smaller than in the case of initialization vectors.

## References

* [Web Authentication](https://www.w3.org/TR/webauthn/): An API for accessing Public Key Credentials Level 1, W3C Recommendation, 4 March 2019
* [FIDO Client to Authenticator Protocol (CTAP) v2.0](https://fidoalliance.org/specs/fido-v2.0-ps-20190130/fido-client-to-authenticator-protocol-v2.0-ps-20190130.html#sctn-hmac-secret-extension), Proposed Standard, January 30, 2019
* [SLIP-0010](https://github.com/satoshilabs/slips/blob/master/slip-0010.md): Universal private key derivation from master private key
* [SLIP-0021](https://github.com/satoshilabs/slips/blob/master/slip-0021.md): Hierarchical derivation of symmetric keys
